<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>android/Handler机制详解 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="对于handler相信大家都很熟悉了，它是Android系统提供的线程间通信的利器。这篇文章我们一起来学习一下handler的具体实现机制。Handler位于android.os包下，打开源码，我们先看一下官方说明书 1234567A Handler allows you to send and process &amp;#123;@link Message&amp;#125; and Runnableobjec">
<meta property="og:type" content="article">
<meta property="og:title" content="android&#x2F;Handler机制详解">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2019&#x2F;11&#x2F;24&#x2F;android&#x2F;Handler%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3&#x2F;index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="对于handler相信大家都很熟悉了，它是Android系统提供的线程间通信的利器。这篇文章我们一起来学习一下handler的具体实现机制。Handler位于android.os包下，打开源码，我们先看一下官方说明书 1234567A Handler allows you to send and process &amp;#123;@link Message&amp;#125; and Runnableobjec">
<meta property="og:locale" content="en">
<meta property="og:updated_time" content="2019-09-29T15:46:26.223Z">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-android/Handler机制详解" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/11/24/android/Handler%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3/" class="article-date">
  <time datetime="2019-11-23T16:27:19.343Z" itemprop="datePublished">2019-11-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      android/Handler机制详解
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>对于handler相信大家都很熟悉了，它是Android系统提供的线程间通信的利器。这篇文章我们一起来学习一下handler的具体实现机制。<br>Handler位于android.os包下，打开源码，我们先看一下官方说明书</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">A Handler allows you to send and process &#123;@link Message&#125; and Runnable</span><br><span class="line">objects associated with a thread&apos;s &#123;@link MessageQueue&#125;.  Each Handler</span><br><span class="line">instance is associated with a single thread and that thread&apos;s message</span><br><span class="line">queue.  When you create a new Handler, it is bound to the thread /</span><br><span class="line">message queue of the thread that is creating it -- from that point on,</span><br><span class="line">it will deliver messages and runnables to that message queue and execute</span><br><span class="line">them as they come out of the message queue.</span><br></pre></td></tr></table></figure>
<p>通过上面这段，我们大体上可以得出以下几个信息：</p>
<ol>
<li>handler可以发送和处理Message和Runnable</li>
<li>handler和创建它的线程以及线程中的MessageQueue密不可分</li>
<li>handler一旦创建，它就可以开始工作了</li>
</ol>
<p>首先我们看下handler的构造方法，构造方法有好几个，但是最终其实只有两种：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public Handler(Callback callback, boolean async) &#123;</span><br><span class="line">       if (FIND_POTENTIAL_LEAKS) &#123;</span><br><span class="line">           final Class&lt;? extends Handler&gt; klass = getClass();</span><br><span class="line">           if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;</span><br><span class="line">                   (klass.getModifiers() &amp; Modifier.STATIC) == 0) &#123;</span><br><span class="line">               Log.w(TAG, &quot;The following Handler class should be static or leaks might occur: &quot; +</span><br><span class="line">                   klass.getCanonicalName());</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       mLooper = Looper.myLooper();</span><br><span class="line">       if (mLooper == null) &#123;</span><br><span class="line">           throw new RuntimeException(</span><br><span class="line">               &quot;Can&apos;t create handler inside thread &quot; + Thread.currentThread()</span><br><span class="line">                       + &quot; that has not called Looper.prepare()&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">       mQueue = mLooper.mQueue;</span><br><span class="line">       mCallback = callback;</span><br><span class="line">       mAsynchronous = async;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">     public Handler(Looper looper, Callback callback, boolean async) &#123;</span><br><span class="line">       mLooper = looper;</span><br><span class="line">       mQueue = looper.mQueue;</span><br><span class="line">       mCallback = callback;</span><br><span class="line">       mAsynchronous = async;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>我们对比一下这两种方式，发现其实是一样的，都是给mLooper、mQueue、mCallback和mAsynchronous这四个全局变量赋值。先看下上面那种方式，通过Looper.myLooper()获取了一个looper，那么looper是个什么玩意呢，通过命名我们猜测是一个轮询器，那它又是用来干什么的呢？<br>我们再继续看下looper的官方说明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Class used to run a message loop for a thread.  Threads by default do</span><br><span class="line">  * not have a message loop associated with them; to create one, call</span><br><span class="line">  * &#123;@link #prepare&#125; in the thread that is to run the loop, and then</span><br><span class="line">  * &#123;@link #loop&#125; to have it process messages until the loop is stopped.</span><br></pre></td></tr></table></figure>
<p>上面主要告诉了我们looper用来干什么的，怎么使用的</p>
<p>它是用来启动线程的消息循环的，起初线程是没有消息轮询器的，需要在一个线程中通过调用looper.prepare方法来创建一个轮询器启动轮询，然后再调用loop方法来处理消息直至loop结束</p>
<p>看完了这个注释，我相信大家都有几点疑问：</p>
<ol>
<li>既然looper是启动一个线程的消息循环，那么一个线程是不是只有一个looper对象呢？那它又是如何保证这一点的呢？</li>
<li>可以在一个线程中多次调用prepare方法来创建looper吗？</li>
<li>looper是如何停止的呢？</li>
</ol>
<p>首先第一个问题，我们查看一下looper的创建方法prepare以及它的构造方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private Looper(boolean quitAllowed) &#123;</span><br><span class="line">    mQueue = new MessageQueue(quitAllowed);</span><br><span class="line">    mThread = Thread.currentThread();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">private static void prepare(boolean quitAllowed) &#123;</span><br><span class="line">    if (sThreadLocal.get() != null) &#123;</span><br><span class="line">        throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    sThreadLocal.set(new Looper(quitAllowed));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>显然，looper的构造方法是私有的，我们只能通过prepare方法来创建looper对象。prepare中先取存储在sThreadLocal中looper对象，如果取不到的话就new一个新的looper存入sThreadLocal，sThreadLocal是什么呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static final ThreadLocal&lt;Looper&gt; sThreadLocal = new ThreadLocal&lt;Looper&gt;();</span><br></pre></td></tr></table></figure>
<p>是一个ThreadLocal对象，它可以存储线程级别的变量，这也就说明了一个线程只有一个looper。注意下构造方法中需要传入以一个布尔型变量quitAllowed，字面意思是是否允许退出。在构造方法中还创建了一个MessageQueue，这个玩意我们在handler中遇到过。下面我们看下这个MessageQueue：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Low-level class holding the list of messages to be dispatched by a</span><br><span class="line"> * &#123;@link Looper&#125;.  Messages are not added directly to a MessageQueue,</span><br><span class="line"> * but rather through &#123;@link Handler&#125; objects associated with the Looper.</span><br></pre></td></tr></table></figure>
<p>MessageQueue的注释就简单了，它是一个底层类，持有一个消息列表，通过looper来分发消息，MessageQueue不会直接添加消息，而是通过以和looper相关联的handler来发送的。它的构造方法也很简单：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MessageQueue(boolean quitAllowed) &#123;</span><br><span class="line">    mQuitAllowed = quitAllowed;</span><br><span class="line">    mPtr = nativeInit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>记录一个mQuitAllowed和int型的mPtr。具体的我们后面再看。现在回过头来看下handler、looper和MessageQueue三者之间的关系，通过上面分析，我们知道handler中有一个looper对象，而且还是线程级别的，looper中有一个MessageQueue，而且根据注释中提供的信息，我们知道消息是通过handler来发送的，消息分发则是looper来完成的，消息则是储存在MessageQueue中的。</p>
<p>接着我们看下handler是如何发送消息的？<br>通过查看Handler中的相关api，发现最终都会调用enqueueMessage方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123;</span><br><span class="line">    msg.target = this;</span><br><span class="line">    if (mAsynchronous) &#123;</span><br><span class="line">        msg.setAsynchronous(true);</span><br><span class="line">    &#125;</span><br><span class="line">    return queue.enqueueMessage(msg, uptimeMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将自己设置为msg的target，更新msg是否是异步消息，然后调用MessageQueue的enqueueMessage方法。现在我们先看下msg一共有哪几种类型</p>
<ul>
<li>普通消息</li>
<li>异步消息</li>
<li>同步屏障</li>
</ul>
<p>普通消息我们都知道，异步消息就是看名字似乎就是异步消息，那同步屏障是什么呢？它用来堵塞之后的普通消息的，具体来说，消息队列中位于它之后的普通消息都将停止分发处理直到屏障移除，而异步消息不受同步屏障的影响。下面通过一个例子来测试一下上面的结论：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">    T t = new T();</span><br><span class="line">    t.start();</span><br><span class="line"></span><br><span class="line">    final Handler handler = t.gettHandler();</span><br><span class="line">    //添加屏障</span><br><span class="line">    addBarrier(handler);</span><br><span class="line">    //发送一个普通消息</span><br><span class="line">    handler.sendMessage(Message.obtain(handler, 1));</span><br><span class="line">    //发生以一个异步消息</span><br><span class="line">    Message m = Message.obtain();</span><br><span class="line">    m.what = 2;</span><br><span class="line">    m.setAsynchronous(true);</span><br><span class="line">    handler.sendMessage(m);</span><br><span class="line">    //发送一个延迟5s的普通消息</span><br><span class="line">    handler.sendEmptyMessageDelayed(3, 5000);</span><br><span class="line">    //发送一个异步消息来移除屏障</span><br><span class="line">    Message m2 = Message.obtain();</span><br><span class="line">    m2.setAsynchronous(true);</span><br><span class="line">    m2.what = 100;</span><br><span class="line">    handler.sendMessageDelayed(m2, 3000);</span><br><span class="line">    </span><br><span class="line">    public class T extends Thread&#123;</span><br><span class="line"></span><br><span class="line">    @SuppressLint(&quot;HandlerLeak&quot;)</span><br><span class="line">    private Handler tHandler = new Handler()&#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void handleMessage(Message msg) &#123;</span><br><span class="line">            super.handleMessage(msg);</span><br><span class="line">            Log.d(TAG, msg.what + &quot;&quot;);</span><br><span class="line">            if(msg.what == 100)&#123;</span><br><span class="line">                Activity1.this.removeBarrier(this);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    public Handler gettHandler()&#123;</span><br><span class="line">        return tHandler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        Looper.prepare();</span><br><span class="line">        Looper.loop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的demo创建了一个线程T，并启用了looper，首先给handler所在线程的MessageQueue添加一个同步屏障，然后依次发送了一个普通消息、一个异步消息、一个延迟5s的普通消息，以及一个延迟3s的异步消息用来移除屏障，消息的what分别为1、2、3、100。<br>我们先来看下日志输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">2019-09-11 18:29:17.455 16827-16827/com.example.demo D/Activity1: postSyncBarrier success</span><br><span class="line">2019-09-11 18:29:17.539 16827-16827/com.example.demo D/Activity1: run:main</span><br><span class="line">2019-09-11 18:29:17.540 16827-16827/com.example.demo D/Activity1: 2</span><br><span class="line">2019-09-11 18:29:20.458 16827-16827/com.example.demo D/Activity1: 100</span><br><span class="line">2019-09-11 18:29:20.459 16827-16827/com.example.demo D/Activity1: removeBarrier</span><br><span class="line">2019-09-11 18:29:20.461 16827-16827/com.example.demo D/Activity1: removeBarrier success</span><br><span class="line">2019-09-11 18:29:20.462 16827-16827/com.example.demo D/Activity1: 1</span><br><span class="line">2019-09-11 18:29:22.458 16827-16827/com.example.demo D/Activity1: 3</span><br></pre></td></tr></table></figure>
<p>消息的处理顺序为2、1、3，非常符合预期。这里值得一提的是postSyncBarrier和removeSyncBarrier方法，分别是添加和移除同步屏障，但是这两个方法是hide的，需要通过反射调用。<br>我们接着来看下这两个方法，首先看插入屏障方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">private int postSyncBarrier(long when) &#123;</span><br><span class="line">    // Enqueue a new sync barrier token.</span><br><span class="line">    // We don&apos;t need to wake the queue because the purpose of a barrier is to stall it.</span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">        final int token = mNextBarrierToken++;</span><br><span class="line">        final Message msg = Message.obtain();</span><br><span class="line">        msg.markInUse();</span><br><span class="line">        msg.when = when;</span><br><span class="line">        msg.arg1 = token;</span><br><span class="line"></span><br><span class="line">        Message prev = null;</span><br><span class="line">        Message p = mMessages;</span><br><span class="line">        if (when != 0) &#123;</span><br><span class="line">            while (p != null &amp;&amp; p.when &lt;= when) &#123;</span><br><span class="line">                prev = p;</span><br><span class="line">                p = p.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (prev != null) &#123; // invariant: p == prev.next</span><br><span class="line">            msg.next = p;</span><br><span class="line">            prev.next = msg;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            msg.next = p;</span><br><span class="line">            mMessages = msg;</span><br><span class="line">        &#125;</span><br><span class="line">        return token;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法还是比较简单的，主要做了下面几件事：</p>
<ol>
<li>生成一个token，方法就是从0开始依次递增1</li>
<li>生成一个屏障msg，它的arg1就是token</li>
<li>将上面的创建的msg按照时间戳顺序插入到消息链表mMessage中</li>
</ol>
<p>然后我们看下移除屏障的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public void removeSyncBarrier(int token) &#123;</span><br><span class="line">    // Remove a sync barrier token from the queue.</span><br><span class="line">    // If the queue is no longer stalled by a barrier then wake it.</span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">        Message prev = null;</span><br><span class="line">        Message p = mMessages;</span><br><span class="line">        while (p != null &amp;&amp; (p.target != null || p.arg1 != token)) &#123;</span><br><span class="line">            prev = p;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        if (p == null) &#123;</span><br><span class="line">            throw new IllegalStateException(&quot;The specified message queue synchronization &quot;</span><br><span class="line">                    + &quot; barrier token has not been posted or has already been removed.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        final boolean needWake;</span><br><span class="line">        if (prev != null) &#123;</span><br><span class="line">            prev.next = p.next;</span><br><span class="line">            needWake = false;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            mMessages = p.next;</span><br><span class="line">            needWake = mMessages == null || mMessages.target != null;</span><br><span class="line">        &#125;</span><br><span class="line">        p.recycleUnchecked();</span><br><span class="line"></span><br><span class="line">        // If the loop is quitting then it is already awake.</span><br><span class="line">        // We can assume mPtr != 0 when mQuitting is false.</span><br><span class="line">        if (needWake &amp;&amp; !mQuitting) &#123;</span><br><span class="line">            nativeWake(mPtr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>移除屏障主要做了这几件事情：</p>
<ol>
<li>根据token在链表中找到屏障</li>
<li>根据屏障所在的位置来确定是否需要唤醒底层looper，如果这个屏障不是链表头节点则无需唤醒；如果屏障是链表的头节点，其后没有消息或者后面不是一个屏障的情况下需要唤醒。</li>
<li>唤醒调用的是底层的 nativeWake(mPtr)方法，这个方法传入的mPtr其实是C++层的MessageQueue，通过往这个MessageQueue的Looper的管道流中写入一个字符来唤醒管道。</li>
</ol>
<p>现在我们回过头来看一下handler中的enqueueMessage方法，它其实是调用messageQueue的enqueueMessage方法，我们看一下这个方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">boolean enqueueMessage(Message msg, long when) &#123;</span><br><span class="line">    if (msg.target == null) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;Message must have a target.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    if (msg.isInUse()) &#123;</span><br><span class="line">        throw new IllegalStateException(msg + &quot; This message is already in use.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">        if (mQuitting) &#123;</span><br><span class="line">            IllegalStateException e = new IllegalStateException(</span><br><span class="line">                    msg.target + &quot; sending message to a Handler on a dead thread&quot;);</span><br><span class="line">            Log.w(TAG, e.getMessage(), e);</span><br><span class="line">            msg.recycle();</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        msg.markInUse();</span><br><span class="line">        msg.when = when;</span><br><span class="line">        Message p = mMessages;</span><br><span class="line">        boolean needWake;</span><br><span class="line">        if (p == null || when == 0 || when &lt; p.when) &#123;</span><br><span class="line">            // New head, wake up the event queue if blocked.</span><br><span class="line">            msg.next = p;</span><br><span class="line">            mMessages = msg;</span><br><span class="line">            needWake = mBlocked;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // Inserted within the middle of the queue.  Usually we don&apos;t have to wake</span><br><span class="line">            // up the event queue unless there is a barrier at the head of the queue</span><br><span class="line">            // and the message is the earliest asynchronous message in the queue.</span><br><span class="line">            needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous();</span><br><span class="line">            Message prev;</span><br><span class="line">            for (;;) &#123;</span><br><span class="line">                prev = p;</span><br><span class="line">                p = p.next;</span><br><span class="line">                if (p == null || when &lt; p.when) &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                if (needWake &amp;&amp; p.isAsynchronous()) &#123;</span><br><span class="line">                    needWake = false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            msg.next = p; // invariant: p == prev.next</span><br><span class="line">            prev.next = msg;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // We can assume mPtr != 0 because mQuitting is false.</span><br><span class="line">        if (needWake) &#123;</span><br><span class="line">            nativeWake(mPtr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法有点长，但其实还是比较简单的。它主要做了下面两件事：</p>
<ol>
<li>找到应该插入消息的位置并将msg插入</li>
<li>判断是否需要唤醒looper</li>
</ol>
<p>对于第一点，又分为两种情况，一种是要插在链表的头部（链表里面还没有节点或者插入的msg的时间戳小于当前链表头部节点的时间戳），还有一种是插在链表的中间位置。</p>
<p>我们先看下插在头部的情况，就是一个简单的链表插入操作，注意此时要将needWake设置为mBlocked，就是说如果之前是block了我们需要唤醒。至于当前是否被block，我们在后面再分析。</p>
<p>再来看下插入到链表中间的情况，注意代码中有一段很重要的注释，对理解后面的代码很有帮助：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// Inserted within the middle of the queue.  Usually we don&apos;t have to wake</span><br><span class="line">// up the event queue unless there is a barrier at the head of the queue</span><br><span class="line">// and the message is the earliest asynchronous message in the queue.</span><br></pre></td></tr></table></figure>
<p>插入到队列（此处指链表）的中间位置的情况。通常我们不会唤醒MessageQueue，除非消息队列的头部是一个同步屏障并且后面还跟着一个异步消息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous();</span><br></pre></td></tr></table></figure>
<p>这样看来这句代码就好理解了，p.traget == null表示此时的头结点是个屏障（只有屏障的target是null）。</p>
<p>为什么？</p>
<p>还记得handler中的enqueueMessage方法吗：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123;</span><br><span class="line">    msg.target = this;</span><br><span class="line">    if (mAsynchronous) &#123;</span><br><span class="line">        msg.setAsynchronous(true);</span><br><span class="line">    &#125;</span><br><span class="line">    return queue.enqueueMessage(msg, uptimeMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只有在postSyncBarrier方法中创建的屏障msg是没有target的。</p>
<p>言归正传，继续看插入到队列中间的情况，就是遍历链表，找到时间戳比msg要大的msg，然后将msg插入的这个位置。判断是否要唤醒用的是下面这个：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (needWake &amp;&amp; p.isAsynchronous()) &#123;</span><br><span class="line">    needWake = false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个主要是针对头节点为屏障的情况，当发现要插入的消息前一个消息是异步消息时是不需要唤醒的，因为异步消息的时间可能还未到，不能随便唤醒。最后根据needWake变量判断是否要去唤醒。发送消息的流程我们基本上就分析了一遍。除了使用handler直接发送消息外Activity和View中也有发送消息的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">runOnUiThread(new Runnable() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">getWindow().getDecorView().post(new Runnable() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>activity中有runOnUiThread方法，可以在主线程执行一个Runnable方法。我们看下这个方法的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Runs the specified action on the UI thread. If the current thread is the UI</span><br><span class="line"> * thread, then the action is executed immediately. If the current thread is</span><br><span class="line"> * not the UI thread, the action is posted to the event queue of the UI thread.</span><br><span class="line"> *</span><br><span class="line"> * @param action the action to run on the UI thread</span><br><span class="line"> */</span><br><span class="line">public final void runOnUiThread(Runnable action) &#123;</span><br><span class="line">    if (Thread.currentThread() != mUiThread) &#123;</span><br><span class="line">        mHandler.post(action);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        action.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注释说明了这个方法的作用：在主线程执行特定的任务。如果当前的线程是主线程的话就立刻执行，否则这个任务将被封装成一个msg放入主线程的消息队列中。这个方法中有两个变量需要注意下，一个是mUiThread一个是mHandler。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">final void attach(...) &#123;</span><br><span class="line">    ...</span><br><span class="line">    mUiThread = Thread.currentThread();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>mUiThread是在activity的attach方法中赋值的，而attach方法是在ActivityThread中的performLaunchActivity方法中调用的，因此mUiThread就是创建ActivityThread的线程，也就是主线程。mHandler是Activity中创建的一个handler，也就是主线程的handler。<br>再看下View中的post方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * &lt;p&gt;Causes the Runnable to be added to the message queue.</span><br><span class="line"> * The runnable will be run on the user interface thread.&lt;/p&gt;</span><br><span class="line"> *</span><br><span class="line"> * @param action The Runnable that will be executed.</span><br><span class="line"> *</span><br><span class="line"> * @return Returns true if the Runnable was successfully placed in to the</span><br><span class="line"> *         message queue.  Returns false on failure, usually because the</span><br><span class="line"> *         looper processing the message queue is exiting.</span><br><span class="line"> *</span><br><span class="line"> * @see #postDelayed</span><br><span class="line"> * @see #removeCallbacks</span><br><span class="line"> */</span><br><span class="line">public boolean post(Runnable action) &#123;</span><br><span class="line">    final AttachInfo attachInfo = mAttachInfo;</span><br><span class="line">    if (attachInfo != null) &#123;</span><br><span class="line">        return attachInfo.mHandler.post(action);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Postpone the runnable until we know on which thread it needs to run.</span><br><span class="line">    // Assume that the runnable will be successfully placed after attach.</span><br><span class="line">    getRunQueue().post(action);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果attachInfo不为空的话，就用attachInfo中的handler发送消息，也就是将消息插入到这个handler中的消息队列中，那么这个handler是在哪里创建的呢？首先我们要知道attachInfo是在哪里赋值的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void dispatchAttachedToWindow(AttachInfo info, int visibility) &#123;</span><br><span class="line">       mAttachInfo = info;</span><br><span class="line">       ...</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>view的dispatchAttachedToWindow最初是在ViewRootImpl的performTraversals方法中调用的，而当ViewRootImpl开始准备测量绘制之前就已经创建好了attachInfo，具体是在它的构造方法中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public ViewRootImpl(Context context, Display display) &#123;</span><br><span class="line">       ...</span><br><span class="line">       mAttachInfo = new View.AttachInfo(mWindowSession, </span><br><span class="line">           mWindow, display, this, mHandler, this,</span><br><span class="line">               context);</span><br><span class="line">       ...</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>而这个mHandler就是在ViewRootImpl中创建的一个Handler：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">final ViewRootHandler mHandler = new ViewRootHandler();</span><br></pre></td></tr></table></figure>

<p>至此，我们知道了View中mAttachInfo中的handler就是ViewRootImpl中创建的一个handler，而ViewRootImpl是在ActivityThread的handleResumeACtivity方法中创建的，这个方法中会将decorView添加到window中，调用windowManager的addView方法，WindowManager就是在activity的attach方法中创建的PhoneWindow中的WindowManager：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">final void attach(...) &#123;</span><br><span class="line">      ...</span><br><span class="line"></span><br><span class="line">      mWindow = new PhoneWindow(this, window, activityConfigCallback);</span><br><span class="line">      mWindow.setWindowControllerCallback(this);</span><br><span class="line">      mWindow.setCallback(this);</span><br><span class="line">      mWindow.setOnWindowDismissedCallback(this);</span><br><span class="line">      mWindow.getLayoutInflater().setPrivateFactory(this);</span><br><span class="line">      ...</span><br><span class="line">      mWindow.setWindowManager(</span><br><span class="line">              (WindowManager)context.getSystemService(Context.WINDOW_SERVICE),</span><br><span class="line">              mToken, mComponent.flattenToString(),</span><br><span class="line">              (info.flags &amp; ActivityInfo.FLAG_HARDWARE_ACCELERATED) != 0);</span><br><span class="line">      if (mParent != null) &#123;</span><br><span class="line">          mWindow.setContainer(mParent.getWindow());</span><br><span class="line">      &#125;</span><br><span class="line">      mWindowManager = mWindow.getWindowManager();</span><br><span class="line">      ...</span><br><span class="line">  &#125;</span><br><span class="line">  //window中的setWindowManager方法：</span><br><span class="line">  public void setWindowManager(WindowManager wm, IBinder appToken, String appName,</span><br><span class="line">          boolean hardwareAccelerated) &#123;</span><br><span class="line">      mAppToken = appToken;</span><br><span class="line">      mAppName = appName;</span><br><span class="line">      mHardwareAccelerated = hardwareAccelerated</span><br><span class="line">              || SystemProperties.getBoolean(PROPERTY_HARDWARE_UI, false);</span><br><span class="line">      if (wm == null) &#123;</span><br><span class="line">          wm = (WindowManager)mContext.getSystemService(Context.WINDOW_SERVICE);</span><br><span class="line">      &#125;</span><br><span class="line">      mWindowManager = ((WindowManagerImpl)wm).createLocalWindowManager(this);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>WindowManager也就是WindowManagerImpl这个对象了，进去看下发现其内部有个mGlobal代理对象，所有操作都是通过这个代理来实现的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">private final WindowManagerGlobal mGlobal = WindowManagerGlobal.getInstance();</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void addView(@NonNull View view, @NonNull ViewGroup.LayoutParams params) &#123;</span><br><span class="line">    applyDefaultToken(params);</span><br><span class="line">    mGlobal.addView(view, params, mContext.getDisplay(), mParentWindow);</span><br><span class="line">&#125;</span><br><span class="line">// WindowManagerGlobal中的addView</span><br><span class="line">  public void addView(View view, ViewGroup.LayoutParams params,</span><br><span class="line">        Display display, Window parentWindow) &#123;</span><br><span class="line">   ...</span><br><span class="line"></span><br><span class="line">    ViewRootImpl root;</span><br><span class="line">    ...</span><br><span class="line">    root = new ViewRootImpl(view.getContext(), display);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">        // do this last because it fires off messages to start doing things</span><br><span class="line">        try &#123;</span><br><span class="line">            root.setView(view, wparams, panelParentView);</span><br><span class="line">        &#125; catch (RuntimeException e) &#123;</span><br><span class="line">            // BadTokenException or InvalidDisplayException, clean up.</span><br><span class="line">            if (index &gt;= 0) &#123;</span><br><span class="line">                removeViewLocked(index, true);</span><br><span class="line">            &#125;</span><br><span class="line">            throw e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ViewRootImpl真正创建是在这里，也就是说它是在主线程创建的（和创建ActivityThread是一个线程），我们再回到View中的post方法，我们希望将任务放到创建ViewRootImpl的线程队列中执行，注意后面还有一句代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// Postpone the runnable until we know on which thread it needs to run.</span><br><span class="line">// Assume that the runnable will be successfully placed after attach.</span><br><span class="line">getRunQueue().post(action);</span><br></pre></td></tr></table></figure>
<p>看完两行注释，我们知道这个方法的目的：推迟执行这个任务直到我们知道应该在哪个线程执行它，只有在View attach之后我们才会将这个任务插入到消息队列。那是如何做到这一点的呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">private HandlerActionQueue getRunQueue() &#123;</span><br><span class="line">    if (mRunQueue == null) &#123;</span><br><span class="line">        mRunQueue = new HandlerActionQueue();</span><br><span class="line">    &#125;</span><br><span class="line">    return mRunQueue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class HandlerActionQueue &#123;</span><br><span class="line">    private HandlerAction[] mActions;</span><br><span class="line">    private int mCount;</span><br><span class="line"></span><br><span class="line">    public void post(Runnable action) &#123;</span><br><span class="line">        postDelayed(action, 0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void postDelayed(Runnable action, long delayMillis) &#123;</span><br><span class="line">        final HandlerAction handlerAction = new HandlerAction(action, delayMillis);</span><br><span class="line"></span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            if (mActions == null) &#123;</span><br><span class="line">                mActions = new HandlerAction[4];</span><br><span class="line">            &#125;</span><br><span class="line">            mActions = GrowingArrayUtils.append(mActions, mCount, handlerAction);</span><br><span class="line">            mCount++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     public void executeActions(Handler handler) &#123;</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            final HandlerAction[] actions = mActions;</span><br><span class="line">            for (int i = 0, count = mCount; i &lt; count; i++) &#123;</span><br><span class="line">                final HandlerAction handlerAction = actions[i];</span><br><span class="line">                handler.postDelayed(handlerAction.action, handlerAction.delay);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mActions = null;</span><br><span class="line">            mCount = 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>涉及到的代码如上，将任务存在一个数组中，等到attach之后再执行，关注下executeActions何时调用，猜测是在View的dispatchAttachedToWindow方法中调用的，看下这个方法果然如此。</p>
<p>上面我们了解了消息的发出，下面继续阅读处理消息的流程。在ActivityThread的main方法中调用Looper的loop方法去轮询队列中的消息，看下loop方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Run the message queue in this thread. Be sure to call</span><br><span class="line"> * &#123;@link #quit()&#125; to end the loop.</span><br><span class="line"> */</span><br><span class="line">public static void loop() &#123;</span><br><span class="line">    final Looper me = myLooper();</span><br><span class="line">    if (me == null) &#123;</span><br><span class="line">        throw new RuntimeException(&quot;No Looper; Looper.prepare() wasn&apos;t called on this thread.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    final MessageQueue queue = me.mQueue;</span><br><span class="line">    ...</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        Message msg = queue.next(); // might block</span><br><span class="line">        if (msg == null) &#123;</span><br><span class="line">            // No message indicates that the message queue is quitting.</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        msg.target.dispatchMessage(msg);</span><br><span class="line">        ...</span><br><span class="line">        msg.recycleUnchecked();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>省略了部分代码，先取出当前线程的looper和looper中的消息队列，然后在一个循环中从消息队列中取出消息分发给对应的handler处理。这里我们重点看下queue.next方法，注释说这个方法可能会堵塞，带着这个信息我们看下next方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">Message next() &#123;</span><br><span class="line">       // Return here if the message loop has already quit and been disposed.</span><br><span class="line">       // This can happen if the application tries to restart a looper after quit</span><br><span class="line">       // which is not supported.</span><br><span class="line">       final long ptr = mPtr;</span><br><span class="line">       if (ptr == 0) &#123;</span><br><span class="line">           return null;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       int pendingIdleHandlerCount = -1; // -1 only during first iteration</span><br><span class="line">       int nextPollTimeoutMillis = 0;</span><br><span class="line">       for (;;) &#123;</span><br><span class="line">           if (nextPollTimeoutMillis != 0) &#123;</span><br><span class="line">               Binder.flushPendingCommands();</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           nativePollOnce(ptr, nextPollTimeoutMillis);</span><br><span class="line"></span><br><span class="line">           synchronized (this) &#123;</span><br><span class="line">               // Try to retrieve the next message.  Return if found.</span><br><span class="line">               final long now = SystemClock.uptimeMillis();</span><br><span class="line">               Message prevMsg = null;</span><br><span class="line">               Message msg = mMessages;</span><br><span class="line">               if (msg != null &amp;&amp; msg.target == null) &#123;</span><br><span class="line">                   // Stalled by a barrier.  Find the next asynchronous message in the queue.</span><br><span class="line">                   do &#123;</span><br><span class="line">                       prevMsg = msg;</span><br><span class="line">                       msg = msg.next;</span><br><span class="line">                   &#125; while (msg != null &amp;&amp; !msg.isAsynchronous());</span><br><span class="line">               &#125;</span><br><span class="line">               if (msg != null) &#123;</span><br><span class="line">                   if (now &lt; msg.when) &#123;</span><br><span class="line">                       // Next message is not ready.  Set a timeout to wake up when it is ready.</span><br><span class="line">                       nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);</span><br><span class="line">                   &#125; else &#123;</span><br><span class="line">                       // Got a message.</span><br><span class="line">                       mBlocked = false;</span><br><span class="line">                       if (prevMsg != null) &#123;</span><br><span class="line">                           prevMsg.next = msg.next;</span><br><span class="line">                       &#125; else &#123;</span><br><span class="line">                           mMessages = msg.next;</span><br><span class="line">                       &#125;</span><br><span class="line">                       msg.next = null;</span><br><span class="line">                       if (DEBUG) Log.v(TAG, &quot;Returning message: &quot; + msg);</span><br><span class="line">                       msg.markInUse();</span><br><span class="line">                       return msg;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; else &#123;</span><br><span class="line">                   // No more messages.</span><br><span class="line">                   nextPollTimeoutMillis = -1;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               // Process the quit message now that all pending messages have been handled.</span><br><span class="line">               if (mQuitting) &#123;</span><br><span class="line">                   dispose();</span><br><span class="line">                   return null;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               // If first time idle, then get the number of idlers to run.</span><br><span class="line">               // Idle handles only run if the queue is empty or if the first message</span><br><span class="line">               // in the queue (possibly a barrier) is due to be handled in the future.</span><br><span class="line">               if (pendingIdleHandlerCount &lt; 0</span><br><span class="line">                       &amp;&amp; (mMessages == null || now &lt; mMessages.when)) &#123;</span><br><span class="line">                   pendingIdleHandlerCount = mIdleHandlers.size();</span><br><span class="line">               &#125;</span><br><span class="line">               if (pendingIdleHandlerCount &lt;= 0) &#123;</span><br><span class="line">                   // No idle handlers to run.  Loop and wait some more.</span><br><span class="line">                   mBlocked = true;</span><br><span class="line">                   continue;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               if (mPendingIdleHandlers == null) &#123;</span><br><span class="line">                   mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)];</span><br><span class="line">               &#125;</span><br><span class="line">               mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           // Run the idle handlers.</span><br><span class="line">           // We only ever reach this code block during the first iteration.</span><br><span class="line">           for (int i = 0; i &lt; pendingIdleHandlerCount; i++) &#123;</span><br><span class="line">               final IdleHandler idler = mPendingIdleHandlers[i];</span><br><span class="line">               mPendingIdleHandlers[i] = null; // release the reference to the handler</span><br><span class="line"></span><br><span class="line">               boolean keep = false;</span><br><span class="line">               try &#123;</span><br><span class="line">                   keep = idler.queueIdle();</span><br><span class="line">               &#125; catch (Throwable t) &#123;</span><br><span class="line">                   Log.wtf(TAG, &quot;IdleHandler threw exception&quot;, t);</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               if (!keep) &#123;</span><br><span class="line">                   synchronized (this) &#123;</span><br><span class="line">                       mIdleHandlers.remove(idler);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           // Reset the idle handler count to 0 so we do not run them again.</span><br><span class="line">           pendingIdleHandlerCount = 0;</span><br><span class="line"></span><br><span class="line">           // While calling an idle handler, a new message could have been delivered</span><br><span class="line">           // so go back and look again for a pending message without waiting.</span><br><span class="line">           nextPollTimeoutMillis = 0;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>相比较插入消息到队列，取出消息的逻辑还是稍微复杂点的。我们将这个方法拆分为三个部分：<br>首先判断looper是否已经退出了，如果退出了就不再接受消息了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// Return here if the message loop has already quit and been disposed.</span><br><span class="line">// This can happen if the application tries to restart a looper after quit</span><br><span class="line">// which is not supported.</span><br><span class="line">final long ptr = mPtr;</span><br><span class="line">if (ptr == 0) &#123;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二个部分，就是从队列里取消息。我们将这部分的代码精简一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">int nextPollTimeoutMillis = 0;</span><br><span class="line">   for (;;) &#123;</span><br><span class="line">           ...</span><br><span class="line">    </span><br><span class="line">           nativePollOnce(ptr, nextPollTimeoutMillis);</span><br><span class="line">    </span><br><span class="line">           synchronized (this) &#123;</span><br><span class="line">               // Try to retrieve the next message.  Return if found.</span><br><span class="line">               final long now = SystemClock.uptimeMillis();</span><br><span class="line">               Message prevMsg = null;</span><br><span class="line">               Message msg = mMessages;</span><br><span class="line">               if (msg != null &amp;&amp; msg.target == null) &#123;</span><br><span class="line">                   // Stalled by a barrier.  Find the next asynchronous message in the queue.</span><br><span class="line">                   do &#123;</span><br><span class="line">                       prevMsg = msg;</span><br><span class="line">                       msg = msg.next;</span><br><span class="line">                   &#125; while (msg != null &amp;&amp; !msg.isAsynchronous());</span><br><span class="line">               &#125;</span><br><span class="line">               if (msg != null) &#123;</span><br><span class="line">                   if (now &lt; msg.when) &#123;</span><br><span class="line">                       // Next message is not ready.  Set a timeout to wake up when it is ready.</span><br><span class="line">                       nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);</span><br><span class="line">                   &#125; else &#123;</span><br><span class="line">                       // Got a message.</span><br><span class="line">                       mBlocked = false;</span><br><span class="line">                       if (prevMsg != null) &#123;</span><br><span class="line">                           prevMsg.next = msg.next;</span><br><span class="line">                       &#125; else &#123;</span><br><span class="line">                           mMessages = msg.next;</span><br><span class="line">                       &#125;</span><br><span class="line">                       msg.next = null;</span><br><span class="line">                       if (DEBUG) Log.v(TAG, &quot;Returning message: &quot; + msg);</span><br><span class="line">                       msg.markInUse();</span><br><span class="line">                       return msg;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; else &#123;</span><br><span class="line">                   // No more messages.</span><br><span class="line">                   nextPollTimeoutMillis = -1;</span><br><span class="line">               &#125;</span><br><span class="line">    </span><br><span class="line">               // Process the quit message now that all pending messages have been handled.</span><br><span class="line">               if (mQuitting) &#123;</span><br><span class="line">                   dispose();</span><br><span class="line">                   return null;</span><br><span class="line">               &#125;</span><br><span class="line">       ...</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>取消息这个逻辑是在一个for循环中的，循环的退出条件只有两个：找到消息和退出loop。那么如果队列的第一个消息还没有到时间或者队列的头部是一个屏障呢？要知道next方法是有返回值的，也就是说它执行完毕时必须要返回一个值，如果循环结束也没有找到应该返回的msg呢？</p>
<p>这个问题的玄机在这个方法中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nativePollOnce(ptr, nextPollTimeoutMillis);</span><br></pre></td></tr></table></figure>

<p>首先这是一个native方法，java层的looper和Message Queue，在C++层也有对应的实现，只不过和java层的并没有对应关系。我们知道java层的Looper中有个MessageQueue，而C层的MessageQueue中也有一个Looper。我们来看下方法的入参<br>ptr指向全局变量mPtr</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private long mPtr; // used by native code</span><br></pre></td></tr></table></figure>
<p>它是给native层使用的，它是在MessageQueue的构造方法中初始化的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MessageQueue(boolean quitAllowed) &#123;</span><br><span class="line">    mQuitAllowed = quitAllowed;</span><br><span class="line">    mPtr = nativeInit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>nativeInit也是一个native方法，nativeInit()方法实现为android_os_MessageQueue_nativeInit()：[android_os_MessageQueue.cpp]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static jlong android_os_MessageQueue_nativeInit(JNIEnv* env, jclass clazz) &#123;</span><br><span class="line">    NativeMessageQueue* nativeMessageQueue = new NativeMessageQueue();</span><br><span class="line">    if (!nativeMessageQueue) &#123;</span><br><span class="line">        jniThrowRuntimeException(env, &quot;Unable to allocate native queue&quot;);</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    nativeMessageQueue-&gt;incStrong(env);</span><br><span class="line">    return reinterpret_cast(nativeMessageQueue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里面会创建一个native的MessageQueue并将变量引用地址返回给java层保存在mPtr变量中，这样就将java层和native层联系起来。接着看下native层MessageQueue的构造方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">NativeMessageQueue::NativeMessageQueue() :</span><br><span class="line">        mPollEnv(NULL), mPollObj(NULL), mExceptionObj(NULL) &#123;</span><br><span class="line">    mLooper = Looper::getForThread();</span><br><span class="line">    if (mLooper == NULL) &#123;</span><br><span class="line">        mLooper = new Looper(false);</span><br><span class="line">        Looper::setForThread(mLooper);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法里面创建了一个Looper，就是C++层的looper。看下nativePollOnce的第二个参数nextPollTimeoutMillis，它指下次poll的超时时间，也就是本次的堵塞时间。</p>
<ul>
<li>nextPollTimeoutMillis为0：本次不堵塞</li>
<li>nextPollTimeoutMillis为-1：一直堵塞</li>
<li>nextPollTimeoutMillis大于0：最长堵塞nextPollTimeoutMillis长时间</li>
</ul>
<p>我们再总结下nativePollOnce(ptr, nextPollTimeoutMillis);这个方法，首先它是一个可能堵塞的方法，ptr是C++层的MessageQueue对象的地址，通过ptr将java层的消息循环和C++层的消息循环联系起来；nextPollTimeoutMillis是本次调用nativePollOnce可能会堵塞的时间；关于epoll机制，这篇文章写的很详细：<a href="https://pqpo.me/2017/05/03/learn-messagequeue" target="_blank" rel="noopener">https://pqpo.me/2017/05/03/learn-messagequeue</a></p>
<p>接着，我们继续来看下messageQueue的next方法具体做了些什么？</p>
<p>由于初始化nextPollTimeoutMillis为0，那么nativePollOnce方法会立即返回，然后执行下面的操作：</p>
<p>首先判断如果消息队列的头节点为屏障，则继续遍历后续的异步消息，找到当前应该处理的异步消息并返回；</p>
<p>如果头节点不是屏障，则遍历消息队列找到当前应该处理的消息并返回；</p>
<p>如果并没有找到当前需要处理的消息，则需要确定nextPollTimeoutMillis的值：第一种情况是因为当前消息队列为空，那么nextPollTimeoutMillis的值应该设置为-1，也就是一直睡眠直到有消息唤醒；第二种情况是当前的找到的最近的消息还未到时间，因此将nextPollTimeoutMillis设置为他们之间的时间差。</p>
<p>在next方法中除了处理消息外，还对idelhandler做了处理，将其它部分截除，我们看下idlehandler的处理逻辑是怎样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">Message next() &#123;</span><br><span class="line">        ...</span><br><span class="line">        int pendingIdleHandlerCount = -1; // -1 only during first iteration</span><br><span class="line">        int nextPollTimeoutMillis = 0;</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            ...</span><br><span class="line">            nativePollOnce(ptr, nextPollTimeoutMillis);</span><br><span class="line"></span><br><span class="line">            synchronized (this) &#123;</span><br><span class="line">                ...//省略消息处理逻辑</span><br><span class="line">                // If first time idle, then get the number of idlers to run.</span><br><span class="line">                // Idle handles only run if the queue is empty or if the first message</span><br><span class="line">                // in the queue (possibly a barrier) is due to be handled in the future.</span><br><span class="line">                if (pendingIdleHandlerCount &lt; 0</span><br><span class="line">                        &amp;&amp; (mMessages == null || now &lt; mMessages.when)) &#123;</span><br><span class="line">                    pendingIdleHandlerCount = mIdleHandlers.size();</span><br><span class="line">                &#125;</span><br><span class="line">                if (pendingIdleHandlerCount &lt;= 0) &#123;</span><br><span class="line">                    // No idle handlers to run.  Loop and wait some more.</span><br><span class="line">                    mBlocked = true;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (mPendingIdleHandlers == null) &#123;</span><br><span class="line">                    mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)];</span><br><span class="line">                &#125;</span><br><span class="line">                mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // Run the idle handlers.</span><br><span class="line">            // We only ever reach this code block during the first iteration.</span><br><span class="line">            for (int i = 0; i &lt; pendingIdleHandlerCount; i++) &#123;</span><br><span class="line">                final IdleHandler idler = mPendingIdleHandlers[i];</span><br><span class="line">                mPendingIdleHandlers[i] = null; // release the reference to the handler</span><br><span class="line"></span><br><span class="line">                boolean keep = false;</span><br><span class="line">                try &#123;</span><br><span class="line">                    keep = idler.queueIdle();</span><br><span class="line">                &#125; catch (Throwable t) &#123;</span><br><span class="line">                    Log.wtf(TAG, &quot;IdleHandler threw exception&quot;, t);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (!keep) &#123;</span><br><span class="line">                    synchronized (this) &#123;</span><br><span class="line">                        mIdleHandlers.remove(idler);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // Reset the idle handler count to 0 so we do not run them again.</span><br><span class="line">            pendingIdleHandlerCount = 0;</span><br><span class="line"></span><br><span class="line">            // While calling an idle handler, a new message could have been delivered</span><br><span class="line">            // so go back and look again for a pending message without waiting.</span><br><span class="line">            nextPollTimeoutMillis = 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>每次for循环只会执行一次idelhandler，也就是满足当前消息队列为空或者第一个消息还未到时间，即：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pendingIdleHandlerCount &lt; 0</span><br><span class="line">&amp;&amp; (mMessages == null || now &lt; mMessages.when)</span><br></pre></td></tr></table></figure>
<p>当满足条件时，会获取idelhandler集合中的idelhandler处理，每个idelhandler会执行其queueIdle方法，返回值确定是否继续处理idelhandler事件。idlehandler处理完毕时需要将pendingIdleHandlerCount和nextPollTimeoutMillis都设置为0，pendingIdleHandlerCount设置为0是因为在本次for循环中不会再去处理idelhander了，一次for循环只会执行一次idlehandler，只有当经过取出一个需要执行的msg处理完毕后通过Looper.loop再次进入next方法时才会将pendingIdleHandlerCount置为-1，这时再去考虑是否要去（取决于当前是否有消息要处理）idelhandler的集合中取出idelhandler来处理；nextPollTimeoutMillis设置为0是因为可能我们在处理idelhandler的时候新插入了消息进来，所以需要再遍历一次消息队列。</p>
<p>上面分析了MessageQueue的next方法，主要包括三个操作：</p>
<ol>
<li>调用底层判断是否需要睡眠（堵塞）</li>
<li>取出队列中当前时间应该执行的消息，包括普通消息和异步消息</li>
<li>如果当前没有消息要处理，判断是否需要执行IdelHandler</li>
</ol>
<p>接着上面讨论的Looper.loop方法，在这个方法中，我们从消息队列中取出了一个消息，后面是如何处理的呢？这里为了方便再次贴出loop的方法（省略了部分无关代码）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public static void loop() &#123;</span><br><span class="line">       final Looper me = myLooper();</span><br><span class="line">       if (me == null) &#123;</span><br><span class="line">           throw new RuntimeException(&quot;No Looper; Looper.prepare() wasn&apos;t called on this thread.&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">       final MessageQueue queue = me.mQueue;</span><br><span class="line">       ...</span><br><span class="line">       for (;;) &#123;</span><br><span class="line">           Message msg = queue.next(); // might block</span><br><span class="line">           if (msg == null) &#123;</span><br><span class="line">               // No message indicates that the message queue is quitting.</span><br><span class="line">               return;</span><br><span class="line">           &#125;</span><br><span class="line">           try &#123;</span><br><span class="line">               msg.target.dispatchMessage(msg);</span><br><span class="line">               dispatchEnd = needEndTime ? SystemClock.uptimeMillis() : 0;</span><br><span class="line">           &#125; finally &#123;</span><br><span class="line">               if (traceTag != 0) &#123;</span><br><span class="line">                   Trace.traceEnd(traceTag);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           ...</span><br><span class="line">           msg.recycleUnchecked();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>如果取出的msg为null的话则直接return，上面代码中有一行注释，没有消息意味着消息队列已经停止了。这让我们想起来在本文刚开始提过一个问题：</p>
<p>Looper是如何停止的？</p>
<p>这个问题我们现在来找一下答案，首先我们看下Looper中的停止方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Quits the looper.</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * Causes the &#123;@link #loop&#125; method to terminate without processing any</span><br><span class="line"> * more messages in the message queue.</span><br><span class="line"> * &lt;/p&gt;&lt;p&gt;</span><br><span class="line"> * Any attempt to post messages to the queue after the looper is asked to quit will fail.</span><br><span class="line"> * For example, the &#123;@link Handler#sendMessage(Message)&#125; method will return false.</span><br><span class="line"> * &lt;/p&gt;&lt;p class=&quot;note&quot;&gt;</span><br><span class="line"> * Using this method may be unsafe because some messages may not be delivered</span><br><span class="line"> * before the looper terminates.  Consider using &#123;@link #quitSafely&#125; instead to ensure</span><br><span class="line"> * that all pending work is completed in an orderly manner.</span><br><span class="line"> * &lt;/p&gt;</span><br><span class="line"> *</span><br><span class="line"> * @see #quitSafely</span><br><span class="line"> */</span><br><span class="line">public void quit() &#123;</span><br><span class="line">    mQueue.quit(false);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Quits the looper safely.</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * Causes the &#123;@link #loop&#125; method to terminate as soon as all remaining messages</span><br><span class="line"> * in the message queue that are already due to be delivered have been handled.</span><br><span class="line"> * However pending delayed messages with due times in the future will not be</span><br><span class="line"> * delivered before the loop terminates.</span><br><span class="line"> * &lt;/p&gt;&lt;p&gt;</span><br><span class="line"> * Any attempt to post messages to the queue after the looper is asked to quit will fail.</span><br><span class="line"> * For example, the &#123;@link Handler#sendMessage(Message)&#125; method will return false.</span><br><span class="line"> * &lt;/p&gt;</span><br><span class="line"> */</span><br><span class="line">public void quitSafely() &#123;</span><br><span class="line">    mQueue.quit(true);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>停止loop的方法有两种，一种是安全的一种是不安全的，取决于MessageQueue的quit方法。先看下注释，大概了解一下这两种方法的区别：</p>
<ul>
<li>不安全的停止方法</li>
</ul>
<p>会导致Looper.loop方法立即停止，任何再插入消息队列的操作都会失败，并且消息队列中的剩余消息都不会再被分发处理</p>
<ul>
<li>安全的停止方法</li>
</ul>
<p>Looper.loop方法不会立即停止，它会等到消息队列中的非延时消息都处理完毕，但是任何再插入消息队列的操作都会失败</p>
<p>继续看下MessageQueue中的quit方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">void quit(boolean safe) &#123;</span><br><span class="line">    if (!mQuitAllowed) &#123;</span><br><span class="line">        throw new IllegalStateException(&quot;Main thread not allowed to quit.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">        if (mQuitting) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        mQuitting = true;</span><br><span class="line"></span><br><span class="line">        if (safe) &#123;</span><br><span class="line">            removeAllFutureMessagesLocked();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            removeAllMessagesLocked();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // We can assume mPtr != 0 because mQuitting was previously false.</span><br><span class="line">        nativeWake(mPtr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void removeAllFutureMessagesLocked() &#123;</span><br><span class="line">    final long now = SystemClock.uptimeMillis();</span><br><span class="line">    Message p = mMessages;</span><br><span class="line">    if (p != null) &#123;</span><br><span class="line">        if (p.when &gt; now) &#123;</span><br><span class="line">            removeAllMessagesLocked();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            Message n;</span><br><span class="line">            for (;;) &#123;</span><br><span class="line">                n = p.next;</span><br><span class="line">                if (n == null) &#123;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">                if (n.when &gt; now) &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                p = n;</span><br><span class="line">            &#125;</span><br><span class="line">            p.next = null;</span><br><span class="line">            do &#123;</span><br><span class="line">                p = n;</span><br><span class="line">                n = p.next;</span><br><span class="line">                p.recycleUnchecked();</span><br><span class="line">            &#125; while (n != null);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  private void removeAllMessagesLocked() &#123;</span><br><span class="line">    Message p = mMessages;</span><br><span class="line">    while (p != null) &#123;</span><br><span class="line">        Message n = p.next;</span><br><span class="line">        p.recycleUnchecked();</span><br><span class="line">        p = n;</span><br><span class="line">    &#125;</span><br><span class="line">    mMessages = null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>removeAllMessagesLocked就是将消息队列中所有的消息销毁，removeAllFutureMessagesLocked会将大于当前时间的消息销毁。在next方法中，有这样一段处理：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// Process the quit message now that all pending messages have been handled.</span><br><span class="line">             if (mQuitting) &#123;</span><br><span class="line">                 dispose();</span><br><span class="line">                 return null;</span><br><span class="line">             &#125;</span><br></pre></td></tr></table></figure>
<p>在上面调用过quit方法后mQuitting变量的值就是true了，进入调用dispose方法并返回null，这样在looper的loop方法中取出的msg就是null，loop方法就被return了，loop操作结束。看下dispose方法的具体处理：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// Disposes of the underlying message queue.</span><br><span class="line">// Must only be called on the looper thread or the finalizer.</span><br><span class="line">private void dispose() &#123;</span><br><span class="line">    if (mPtr != 0) &#123;</span><br><span class="line">        nativeDestroy(mPtr);</span><br><span class="line">        mPtr = 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实就是销毁底层的消息队列。上面还提到，当调用quit方法后，如果再次使用handler发送消息，消息是不会成功插入队列的，因为MessageQueue的enqueueMessage方法中做了判断：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if (mQuitting) &#123;</span><br><span class="line">        IllegalStateException e = new IllegalStateException(</span><br><span class="line">                msg.target + &quot; sending message to a Handler on a dead thread&quot;);</span><br><span class="line">        Log.w(TAG, e.getMessage(), e);</span><br><span class="line">        msg.recycle();</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>还有一个点需要注意一下，MessageQueue的quit方法的最后调用了nativeWake方法唤醒的底层的消息队列，因为如果MessageQueue的next当前在堵塞的话，需要return null停止loop循环，不能一直处于堵塞状态。<br>至此，looper的停止流程就分析完了。</p>
<p>如果Looper.loop方法中取出的msg不是null，则将会执行代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msg.target.dispatchMessage(msg);</span><br></pre></td></tr></table></figure>
<p>msg.target就是发送msg的handler，我们进入到Handler的dispatchMessage方法中看一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * Handle system messages here.</span><br><span class="line"> */</span><br><span class="line">public void dispatchMessage(Message msg) &#123;</span><br><span class="line">    if (msg.callback != null) &#123;</span><br><span class="line">        handleCallback(msg);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (mCallback != null) &#123;</span><br><span class="line">            if (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        handleMessage(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> private static void handleCallback(Message message) &#123;</span><br><span class="line">        message.callback.run();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> /**</span><br><span class="line"> * Callback interface you can use when instantiating a Handler to avoid</span><br><span class="line"> * having to implement your own subclass of Handler.</span><br><span class="line"> */</span><br><span class="line">public interface Callback &#123;</span><br><span class="line">    /**</span><br><span class="line">     * @param msg A &#123;@link android.os.Message Message&#125; object</span><br><span class="line">     * @return True if no further handling is desired</span><br><span class="line">     */</span><br><span class="line">    public boolean handleMessage(Message msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Subclasses must implement this to receive messages.</span><br><span class="line"> */</span><br><span class="line">public void handleMessage(Message msg) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据上面的代码，msg的分发逻辑如下：</p>
<ol>
<li>如果msg设置了callback，则执行callback的run方法，那么callback是何时设置的呢？handler的post系列的方法中需要传递一个Ruannable类型的参数，handler中有个方法将这个参数封装成一个msg：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private static Message getPostMessage(Runnable r) &#123;</span><br><span class="line">    Message m = Message.obtain();</span><br><span class="line">    m.callback = r;</span><br><span class="line">    return m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>如果在创建handler对象时传递了callback参数，则调用传递的callback的handleMessage方法来处理</li>
<li>如果都不上面两种情况，则执行handler自己的handleMessage方法。</li>
</ol>
<p>对于handler机制，基本就是这么多内容了，总结一下就是下面几个方面的内容：</p>
<ul>
<li>消息循环系统的创建（handler、Looepr和MessageQueue）</li>
<li>消息循环的启动</li>
<li>消息的发送</li>
<li>消息的轮询机制</li>
<li>消息循环的终止</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/11/24/android/Handler%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3/" data-id="ck3bse9rb0000fsvjbweu8hyk" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/11/24/android/Handler%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3/">android/Handler机制详解</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>